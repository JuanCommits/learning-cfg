from base.alphabet import VPAlphabet, RankedAlphabet
from base.tree import Tree, TreeSymbol, empty_symbol, epsilon
from tree_automata.tree_state import TreeAutomataState, TreeAutomataTransitionKey
from tree_automata.tree_automata import TreeAutomata


def is_well_formed(sequence: str, alphabet: VPAlphabet) -> bool:
    return belongs_to_most_permissive_vpg(alphabet, sequence)


def tree_is_well_formed(tree: Tree, alphabet: RankedAlphabet) -> bool:
    """
    Check if the tree is well-formed according to the rules of the most permissive VPG.
    A tree is well-formed if it can be generated by a VPL with the given alphabet.
    """
    tree_automaton = get_most_permissive_vpg_as_tree_automaton(alphabet)
    return tree_automaton.is_accepted(tree)


def get_most_permissive_vpg_as_tree_automaton(alphabet: RankedAlphabet) -> TreeAutomata:
    """
    Get the most permissive VPG as a tree automaton.
    The most permissive VPG accepts all sequences that can be generated by
    a VPL with the given alphabet.
    """
    s_state = TreeAutomataState('s_state')

    rank_zero_symbol = empty_symbol
    rank_one_symbols = alphabet.get_symbols_by_arity(1)
    rank_two_symbols = alphabet.get_symbols_by_arity(2)

    rank_zero_transitions = {
        TreeAutomataTransitionKey(rank_zero_symbol, []): s_state
    }

    rank_one_transitions = {
        TreeAutomataTransitionKey(symbol, [s_state]): s_state for symbol in rank_one_symbols
    }

    rank_two_transitions = {
        TreeAutomataTransitionKey(symbol, [s_state, s_state]): s_state for symbol in rank_two_symbols
    }
    transitions = {**rank_zero_transitions, **rank_one_transitions, **rank_two_transitions}
    states = {s_state}

    return TreeAutomata(
        states=states,
        alphabet=alphabet,
        final_states={s_state},
        transitions=transitions
    )
    
    

def belongs_to_most_permissive_vpg(alphabet: VPAlphabet, sequence: str) -> bool:
    """
    Check if the sequence belongs to the most permissive VPG.
    The most permissive VPG accepts all sequences that can be generated by
    a VPL with the given alphabet.
    """

    # Check if the sequence is well-formed
    if not sequence:
        return True

    # Check if the sequence contains only symbols from the alphabet
    for symbol in sequence:
        if symbol not in alphabet.get_all_symbols():
            return False

    # Check if the sequence is well-formed according to the rules of VPG
    stack = []
    for symbol in sequence:
        if symbol in alphabet.get_push_symbols():
            stack.append(symbol)
        elif symbol in alphabet.get_pop_symbols():
            if not stack:
                return False
            stack.pop()
        elif symbol in alphabet.get_int_symbols():
            continue

    return len(stack) == 0
